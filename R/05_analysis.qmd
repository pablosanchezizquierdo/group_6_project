---
title: "05_analysis"
format: html
editor: visual
---

## Load augment dataset from step 4

```{r}
tsv_file <- "../data/data_augmented.tsv"
data_augmented <- read_tsv(tsv_file)
```

```{r}
### Extract a vector of sequences

# Split the dataset based on compound name
compound_lists <- data_augmented |>
  filter(!is.na(Sequence)) |> 
  group_by(Compound_Name) |> 
  summarise(ProteinSequences = list(Sequence))

# Print or use the list of sequences for each compound
#print(compound_lists)

```

```{r}
#library("ggseqlogo")

# Perform MSA on each list of sequences
aligned_compounds <- compound_lists |>
  filter(map_lgl(ProteinSequences, ~length(.x) < 200)) |> 
  mutate(MSA = map(ProteinSequences, ~msa(.x, type = "protein")))

#print(aligned_compounds$AlignedSequences)

```

## Consensus sequence

Extract consensus sequence from MSA and check the percentage of gaps and missing positions.

```{r}
calculate_percentage <- function(consensus_sequence) {
    
    count <- str_count(consensus_sequence, fixed("-")) + str_count(consensus_sequence, fixed("?"))
    total <- nchar(consensus_sequence)
    percentage <- (count / total) * 100

    return(percentage)
}

aligned_compounds <- aligned_compounds |>
  mutate(consensus_sequence = map(MSA, ~consensusString(consensusMatrix(.x)))) |>
  mutate(percentage = unlist(map(consensus_sequence, ~calculate_percentage(.x))))
  
```

Plot the percentages for each compound

```{r}
aligned_compounds |>
  ggplot(aes(x = Compound_Name, y = percentage)) + 
    geom_bar(stat = "identity", fill = "steelblue") +
    theme_minimal() +
    theme(axis.text.x = element_text(size = 8, angle = 45, hjust = 1, vjust = 1), axis.text.y = element_text(size = 8))
    labs(title = "Percentage of missing positions for each compound alignment", x = "Compounds", y = "Percentage")
```

## Aligned sequences

We extract aligned sequences from MSA alignment to perform posterior analysis

```{r}
aligned_compounds <- aligned_compounds |>
  mutate(aligned_sequences = map(MSA, ~msaConvert(.x, type="bios2mds::align"))) |>
  mutate(aligned_sequences = map(aligned_sequences, ~map(.x, ~paste(.x, collapse = ""))))
```

## Clustering

### Distance matrix

```{r}
aligned_compounds <- aligned_compounds |>
  mutate(distance_matrix = map(MSA, ~msaConvert(.x, type="seqinr::alignment"))) |>
  mutate(distance_matrix = map(distance_matrix, ~dist.alignment(.x, "identity")))
```

### Clustering

#### Phylogenetic trees

```{r}
aligned_compounds <- aligned_compounds |>
  mutate(phylo_tree = map(distance_matrix, ~njs(.x)))
```

```{r}
#map(aligned_compounds$phylo_tree, plot(.x, cex = 0.6))
map(aligned_compounds$phylo_tree, function(tree) {
  plot(tree, cex = 0.6)
})
```

```{r}
phylogenetic_tree <- njs(aligned_compounds$distance_matrix[2][[1]])
plot(phylogenetic_tree, main="Phylogenetic Tree of Hemoglobin Alpha Sequences", cex=0.6)
```

Sequence logo

```{r}

```


```{r}
# Apply Multidimensional Scaling
mds_result <- cmdscale(aligned_compounds$distance_matrix[5][[1]], k=2) # k is the number of dimensions, usually 2 or 3

# Plotting the result
plot(mds_result, type="n", xlab="Dimension 1", ylab="Dimension 2", main="MDS Plot")
text(mds_result, labels=rownames(mds_result), pos=4, cex=0.6)
matrix_length <- nrow(aligned_compounds$distance_matrix[5][[1]])
sample_labels <- seq(1, matrix_length)
text(mds_result, labels=sample_labels, pos=4, cex=0.7)
```

```{r}
aligned_compounds <- aligned_compounds |>
  mutate(phylogenetic_tree = map(distance_matrix, ~njs(.x)))
#hemoTree <- nj(d)
#plot(hemoTree, main="Phylogenetic Tree of Hemoglobin Alpha Sequences")
```

## Core sequences

In order to make sequence logos on the core sequences, we need to calculate the best 9mer.

```{r}
conMat <- consensusMatrix(aligned_compounds$MSA[17][[1]])

mer_position_function <- function(consensus_mat) {
  consensus_mat <- consensus_mat |>
      as.data.frame() |>
      mutate(position = row_number()) |>
      pivot_longer(-position, names_to = "position_aa", values_to = "aa") |>
      group_by(position) |>
      mutate(position_score = max(aa)) |>
      select(position, position_score) |>
      distinct(position, .keep_all = TRUE)
  
  consensus_mat <- data.frame(
    position = consensus_mat$position,
    position_score = consensus_mat$position_score
  )
  
  mer_position <- consensus_mat |>
    mutate(mer_score = lead(position_score, n=1, default = 0) + lead(position_score, n=1, default = 0) + lead(position_score, n=2, default = 0) + lead(position_score, n=3, default = 0) + lead(position_score, n=4, default = 0) + lead(position_score, n=5, default = 0) + lead(position_score, n=6, default = 0) + lead(position_score, n=7, default = 0) + lead(position_score, n=8, default = 0)) |>
    filter(mer_score == max(mer_score)) |>
    slice_head(n = 1) |>
    select(position) |>
    pull()
  
  return(mer_position)
}

aligned_compounds <- aligned_compounds |>
  mutate(conMat = map(MSA, ~consensusMatrix(.x))) |>
  mutate(mer_position = map(conMat, ~mer_position_function(.x)))
```


```{r}
aligned_compounds <- aligned_compounds |>
  mutate(extracted_chars = map(aligned_sequences, ~map(.x, ~str_sub(.x, 6, 6 + 8))))
```


```{r}
aligned_compounds <- aligned_compounds |>
  mutate(extracted_chars = map2(aligned_sequences, mer_position, ~map2(.x, rep(.y, length(.x)), ~str_sub(., .y, .y + 8)))) |>
  mutate(extracted_chars = map(extracted_chars, ~unlist(.x)))

aligned_compounds <- aligned_compounds |>
  mutate(seqlogo = map(extracted_chars, ~ggseqlogo(.x, seq_type = "aa")))
```

```{r}
aligned_compounds$seqlogo[5]
```

```{r}
aligned_compounds <- aligned_compounds |>
  mutate(extracted_chars = map2(aligned_sequences, mer_position, ~map(.x, ~str_sub(., .y, .y + 8))))

aligned_compounds <- aligned_compounds |>
  mutate(seqlogo = map(extracted_chars, ~ggseqlogo(.x, seq_type = "aa")))
```

```{r}
aligned_compounds <- aligned_compounds |>
  mutate(extracted_chars = map2(aligned_sequences[[1]], mer_position, ~map_chr(.x, ~substr(., .y, .y + 8))))
```


## Plotting MSA

Plot sequence logos on the MSA using the 9mer got before (starting position stored in mer_position)

```{r}
alignment <- aligned_compounds$MSA[17][[1]]

```

```{r}

plot_MSA <- function(MSA){
  plot <- msaPrettyPrint(MSA, output="pdf", y=c(mer_position, mer_position + 8), showNames="none", showLogo="top",
  logoColors="rasmol", shadingMode="similar",
  showLegend=FALSE, askForOverwrite=FALSE)
}

aligned_compounds |>
  map(MSA, ~plot_MSA(.x))
```

```{r}
# Define the plot_MSA function
plot_MSA <- function(MSA) {
  plot <- msaPrettyPrint(
    MSA, 
    output = "pdf", 
    y = c(9, 18),  # Assuming 'mer_position' is defined somewhere
    showNames = "none", 
    showLogo = "top",
    logoColors = "rasmol", 
    shadingMode = "similar",
    showLegend = FALSE, 
    askForOverwrite = FALSE
  )
  return(plot)  # Return the 'plot' object
}

# Apply the plot_MSA function to each element in the "MSA" column using map
result_list <- aligned_compounds %>%
  mutate(plot_result = map(MSA, plot_MSA))
```

```{r}
hamming_distance <- function(seq1, seq2) {
    # Ensure the sequences are character strings
    seq1 <- as.character(seq1)
    seq2 <- as.character(seq2)
    # Check if lengths are equal
    if (nchar(seq1) != nchar(seq2)) {
        stop("Sequences must be of the same length")
    }

    # Convert strings to vectors of characters
    chars_seq1 <- strsplit(seq1, "")[[1]]
    chars_seq2 <- strsplit(seq2, "")[[1]]

    # Calculate Hamming distance
    return(sum(chars_seq1 != chars_seq2))
}
calculate_distance_matrix <- function(sequences_list) {
    n <- length(sequences_list)
    distance_matrix <- matrix(nrow = n, ncol = n)
    
    for (i in 1:n) {
        for (j in 1:n) {
            distance_matrix[i, j] <- hamming_distance(sequences_list[[i]], sequences_list[[j]])
        }
    }
    
    return(distance_matrix)
}
```

```{r}
aligned_compounds <- aligned_compounds |>
  mutate(distance_matrix_2 = map(aligned_sequences, ~calculate_distance_matrix(.x)))
```

```{r}
print()
```

```{r}
# Function to compute the complete linkage distance between two clusters
complete_linkage_distance <- function(cluster1, cluster2, dist_matrix) {
  max(sapply(cluster1, function(i) {
    sapply(cluster2, function(j) {
      dist_matrix[i, j]
    })
  }))
}

# Hierarchical clustering function
hierarchical_clustering <- function(dist_matrix) {
  clusters <- list(seq_len(nrow(dist_matrix)))
  while (length(clusters) > 1) {
    # Find the pair of clusters with the smallest complete linkage distance
    min_dist <- Inf
    min_pair <- c(0, 0)
    for (i in 1:(length(clusters) - 1)) {
      for (j in (i + 1):length(clusters)) {
        dist <- complete_linkage_distance(clusters[[i]], clusters[[j]], dist_matrix)
        if (dist < min_dist) {
          min_dist <- dist
          min_pair <- c(i, j)
        }
      }
    }
    
    # Merge the closest pair of clusters
    new_cluster <- c(clusters[[min_pair[1]]], clusters[[min_pair[2]]])
    clusters <- clusters[-c(min_pair[1], min_pair[2])]
    clusters <- c(clusters, list(new_cluster))
  }
  
  return(clusters[[1]])
}
```

```{r}
distance_matrix <- aligned_compounds$distance_matrix_2[2]
distance_matrix_2 <- distance_matrix[[1]]
class(distance_matrix_2)
#aligned_compounds$distance_matrix[1]
is.matrix(distance_matrix_2)
#clusters <- hierarchical_clustering(distance_matrix_2)
#print(clusters)
```

```{r}
# Apply Multidimensional Scaling
mds_result <- cmdscale(distance_matrix_2, k=2) # k is the number of dimensions, usually 2 or 3

# Plotting the result
plot(mds_result, type="n", xlab="Dimension 1", ylab="Dimension 2", main="MDS Plot")
text(mds_result, labels=rownames(mds_result), pos=4, cex=0.6)
matrix_length <- nrow(distance_matrix_2)
sample_labels <- seq(1, matrix_length)
text(mds_result, labels=sample_labels, pos=4, cex=0.7)
```

```{r}
# Define a custom function to process each element
process_sequence <- function(alignment_row) {
    # Extract the first element of the list in the row
    #alignment_2 <- alignment_row[[1]]
    
    # Convert the alignment
    alignment_3 <- msaConvert(alignment_2, type="bios2mds::align")
    
    # Concatenate the sequences
    alignment_4 <- lapply(alignment_row, function(x) paste(x, collapse = ""))
    
    return(alignment_4)
}

# Apply the function to each row of the AlignedSequences column
processed_sequences <- lapply(aligned_compounds$AlignedSequences, process_sequence)

# 'processed_sequences' now contains the processed data for each row
```

```{r}
hemoAln3_1 <- hemoAln3[1]
hemoAln3_1 <- hemoAln3_1[[1]]
print(hemoAln3_1[1])
```

```{r}
ProteinSequences <- aligned_compounds$ProteinSequences[1]
#ProteinSequences <- ProteinSequences[[1]]
print(ProteinSequences)
```

```{r}
compound_lists_2 <- data_augmented |>
  filter(!is.na(Sequence)) |> 
  group_by(Compound_Name) |>
  summarise(ProteinSequences = list(Sequence))
```

```{r}
specific_compound <- compound_lists_2 |> 
  filter(Compound_Name == "Endosulfan") |> 
  pull(ProteinSequences)

# This will print the sequences for the chosen compound
print(specific_compound)
```

```{r}
# Concatenate all elements into a single string
concatenated_string <- paste(hemoAln3_1, collapse = "")
```

```{r}
str(hemoAln3)
```

```{r}
print(alignment)
```

## Phylogenetic tree

```{r}
library(phylocom)
```

```{r}
consensus_seq <- consensusSequence(alignment)
```

```{r}
library(Biostrings)
```

```{r}
print(alignment)
```

```{r}
# Assuming 'alignment' is your MSA object
cons_matrix <- consensusMatrix(alignment)
cons_seq <- consensusString(cons_matrix)
print(cons_seq)
```

```{r}
alignedSequences <- msaConvert(alignment, type="AAMultipleAlignment")
```

```{r}
library("ape")
library("seqinr")
```

```{r}
# The msa object stores sequences in a list-like structure
alignedSequences <- alignment@seqs

# Convert to a vector of strings
sequenceVector <- sapply(alignedSequences, as.character)
```

```{r}
hemoAln3 <- msaConvert(alignment, type="bios2mds::align")
str(hemoAln3)
```

```{r}
hemoAln4 <- as(alignment, "BStringSet")
hemoAln4
```

```{r}
alignment_object_first_row <- aligned_compounds$AlignedSequences[18]
alignment <- alignment_object_first_row[[1]]
```

```{r}
msaPrettyPrint(alignment, output="tex", y=c(164, 213),
subset=c(1:6), showNames="none", showLogo="none",
consensusColor="ColdHot", showLegend=FALSE,
askForOverwrite=FALSE)
```

```{r}
# Redirecting the output of msaPrettyPrint to a temporary file
tempFile <- tempfile()
sink(tempFile)
msaPrettyPrint(alignment, output="fasta")
sink()

# Reading back the content
alignedSequences <- readLines(tempFile)

# Cleaning up the temporary file
unlink(tempFile)

# Process the content to extract sequences
sequences <- alignedSequences[grep(">", alignedSequences, invert = TRUE)]
sequenceVector <- paste(sequences, collapse = "")
```

```{r}
library(texshade)
```

```{r}
library(seqinr)
d <- dist.alignment(aligned_compunds$AlignedSequences, "identity")
#as.matrix(d)[2:5, "HBA1_Homo_sapiens", drop=FALSE]
```

```{r}

# Function to extract 9-mers from the aligned sequence
extract_9mers <- function(alignment, positions) {
  s2 <- unname(as.character(alignment))
  lapply(positions, function(pos) toString(s2[(pos - 4):(pos + 4)]))
}

# Perform MSA on each list of sequences
aligned_compounds <- compound_lists %>%
  filter(map_lgl(ProteinSequences, ~length(.x) == 168)) %>%
  mutate(
    AlignedSequences = map(ProteinSequences, ~msa(.x, type = "protein")),
    Conserved9mers = map(AlignedSequences, ~{
      consensus <- consensusMatrix(.x)
      most_conserved_positions <- which(consensus >= 0.5)  # You can adjust the threshold as needed
      # Extract 9-mers around the most conserved positions
      extract_9mers(.x, most_conserved_positions)
    })
  )

# Print or use the aligned sequences and most conserved 9-mers for each compound
print(aligned_compounds)
```

```{r}
# Print the conserved 9-mers for each compound
Conserved9mers <- aligned_compounds %>%
  select(`Compound Name`, Conserved9mers) %>%
  unnest(Conserved9mers)

```

```{r}

# Function to extract the most conserved 9-mer from the aligned sequence
extract_most_conserved_9mer <- function(alignment, positions) {
  s2 <- unname(as.character(alignment))
  if (length(positions) > 0) {
    most_conserved_position <- positions[which.max(consensusMatrix(alignment)[positions])]
    return(toString(s2[(most_conserved_position - 4):(most_conserved_position + 4)]))
  } else {
    return(NA)
  }
}

# Perform MSA on each list of sequences
aligned_compounds <- compound_lists %>%
  filter(map_lgl(ProteinSequences, ~length(.x) < 168)) %>%
  mutate(
    AlignedSequences = map(ProteinSequences, ~msa(.x, type = "protein")),
    Conserved9mers = map(AlignedSequences, ~{
      consensus <- consensusMatrix(.x)
      most_conserved_positions <- which(consensus >= 0.5)  # You can adjust the threshold as needed
      # Extract the most conserved 9-mer around the most conserved position
      extract_most_conserved_9mer(.x, most_conserved_positions)
    })
  ) %>%
  select(`Compound Name`, ProteinSequences, Conserved9mers) %>%
  unnest(ProteinSequences, Conserved9mers)

# Print the conserved 9-mers for each sequence and compound
print(aligned_compounds)


```

```{r}

library(Biostrings)
library(dplyr)

# Assuming your dataset is named 'aligned_compounds' and the second column is named 'ProteinSequences'
aligned_compounds <- aligned_compounds %>%
  mutate(conserved_aa = map_chr(AlignedSequences, ~{
    # Create a AAStringSet object from the sequences
    aa_strings <- AAStringSet(.x)
    
    # Create a consensus matrix from the AAStringSet object
    consensus_matrix <- consensusMatrix(aa_strings)
    
    # Extract the 9 most conserved amino acids from the consensus matrix
    conserved_aa <- names(sort(consensus_matrix, decreasing = TRUE)[1:9])
    
    # Return the 9 most conserved amino acids as a string
    return(paste(conserved_aa, collapse = ","))
  }))

# Print the updated dataset
print(aligned_compounds$conserved_aa)


```
